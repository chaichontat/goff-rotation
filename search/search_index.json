{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home This project repurposes the Illumina HiSeq 2000/2500 into an epifluorescence microscope with fluidics control. An overarching goal is to provide an accessible production-level software to control the HiSeq. The system could be controlled through a command line interface and a web interface. PySeq 2501 is written in Python 3.10 but should also work with 3.9. Acknowledgements This repurposing project is possible thanks to the pioneering work of Pandit et al. for PySeq2500 ( GitHub ). Much of the technical details and breadcrumbs are available thanks to the HiSeq2000 - Next Level Hacking project from Urs Gaudenz and the ReSeq Hackteria team.","title":"Home"},{"location":"#home","text":"This project repurposes the Illumina HiSeq 2000/2500 into an epifluorescence microscope with fluidics control. An overarching goal is to provide an accessible production-level software to control the HiSeq. The system could be controlled through a command line interface and a web interface. PySeq 2501 is written in Python 3.10 but should also work with 3.9.","title":"Home"},{"location":"#acknowledgements","text":"This repurposing project is possible thanks to the pioneering work of Pandit et al. for PySeq2500 ( GitHub ). Much of the technical details and breadcrumbs are available thanks to the HiSeq2000 - Next Level Hacking project from Urs Gaudenz and the ReSeq Hackteria team.","title":"Acknowledgements"},{"location":"architecture/","text":"Architecture Serial Each file corresponds to an instrument controlled by a serial port. The FPGA or the \"computer\" of the HiSeq controls more instruments directly. This is presumably due to instrument interfaces and lower latency requirements. A single thread, running an asynchronous event loop, serves as a bridge for all serial communications. This allows concurrent signaling across multiple instruments, dramatically increasing the throughput of the system. Multiple commands could be sent at once and each incoming message could be processed nearly instantaneously without waiting for the last command to finish. Commands Lists of commands are available in the beginning of all files. Commands can be of two formats: Callable[..., str] or str for commands with and without arguments. For commands that elicit a response from an instrument, bundling a command with a parser using CmdParse is highly recommended. Sending a CmdParse command results in a Future object, which could be used to access the parsed response once it is completed. Any responses that could not be accounted for using a CmdParse object would trigger a warning as these often indicate deviations from a typical behavior. Since commands are sent without waiting for the previous one to return, a deluge of commands could overwhelm an instrument. In this case, use the min_spacing keyword argument to specify the minimum temporal spacing between commands, defaults to 0.1 seconds. Camera PySeq 2501 communicates with the camera through a DLL file dcamapi.dll from Hamamatsu, which probably communicates with the camera through Camera Link . PySeq 2501 is only guaranteed to work with the original driver version from Illumina. I have tried the latest API from Hamamatsu without much success. The response time is also much better than that over serial communication.","title":"Architecture"},{"location":"architecture/#architecture","text":"","title":"Architecture"},{"location":"architecture/#serial","text":"Each file corresponds to an instrument controlled by a serial port. The FPGA or the \"computer\" of the HiSeq controls more instruments directly. This is presumably due to instrument interfaces and lower latency requirements. A single thread, running an asynchronous event loop, serves as a bridge for all serial communications. This allows concurrent signaling across multiple instruments, dramatically increasing the throughput of the system. Multiple commands could be sent at once and each incoming message could be processed nearly instantaneously without waiting for the last command to finish.","title":"Serial"},{"location":"architecture/#commands","text":"Lists of commands are available in the beginning of all files. Commands can be of two formats: Callable[..., str] or str for commands with and without arguments. For commands that elicit a response from an instrument, bundling a command with a parser using CmdParse is highly recommended. Sending a CmdParse command results in a Future object, which could be used to access the parsed response once it is completed. Any responses that could not be accounted for using a CmdParse object would trigger a warning as these often indicate deviations from a typical behavior. Since commands are sent without waiting for the previous one to return, a deluge of commands could overwhelm an instrument. In this case, use the min_spacing keyword argument to specify the minimum temporal spacing between commands, defaults to 0.1 seconds.","title":"Commands"},{"location":"architecture/#camera","text":"PySeq 2501 communicates with the camera through a DLL file dcamapi.dll from Hamamatsu, which probably communicates with the camera through Camera Link . PySeq 2501 is only guaranteed to work with the original driver version from Illumina. I have tried the latest API from Hamamatsu without much success. The response time is also much better than that over serial communication.","title":"Camera"},{"location":"hiseq/","text":"HiSeq The system we have is a HiSeq 2000 from 2012. Detailed specifications could be found here. Basically, it's an epifluorescence microscope with an integrated fluidics system. Each channel is a Hamamatsu C10000-509 CCD camera with a resolution of 2048 * 128 pixels. We would typically use the TDI (time delay and integration) mode. Briefly, we synchronize the speed of the stage and signal collection such that a running charge remains \"stationary\" with respect to an image point. This is much better than a typical full \"area\" shot as we could not take an image when we are moving. Thinking in terms of the original purpose of the HiSeq reveals much of the engineering decisions. The system needs to image diffraction-limited points on a 2D plane over distances in the order of centimeters. By using TDI, we could image an entire vertical slice of a flow cell at high-speed without stitching. Another issue is \\(z\\) -drift. This is dealt with by using 3 separate motors to control the stage height and tilt. The next problem would be ensuring that two parallel images start and end exactly at the same place. This is presumably done by using a direct FPGA-camera link that can send \"trigger\" signals. Details from an analogous model could be found here. The FPGA can precisely trigger the camera when the \\(y\\) position and \\(z\\) position reaches a certain value.","title":"Overview"},{"location":"hiseq/#hiseq","text":"The system we have is a HiSeq 2000 from 2012. Detailed specifications could be found here. Basically, it's an epifluorescence microscope with an integrated fluidics system. Each channel is a Hamamatsu C10000-509 CCD camera with a resolution of 2048 * 128 pixels. We would typically use the TDI (time delay and integration) mode. Briefly, we synchronize the speed of the stage and signal collection such that a running charge remains \"stationary\" with respect to an image point. This is much better than a typical full \"area\" shot as we could not take an image when we are moving. Thinking in terms of the original purpose of the HiSeq reveals much of the engineering decisions. The system needs to image diffraction-limited points on a 2D plane over distances in the order of centimeters. By using TDI, we could image an entire vertical slice of a flow cell at high-speed without stitching. Another issue is \\(z\\) -drift. This is dealt with by using 3 separate motors to control the stage height and tilt. The next problem would be ensuring that two parallel images start and end exactly at the same place. This is presumably done by using a direct FPGA-camera link that can send \"trigger\" signals. Details from an analogous model could be found here. The FPGA can precisely trigger the camera when the \\(y\\) position and \\(z\\) position reaches a certain value.","title":"HiSeq"},{"location":"programs/","text":"From the logs, there are 3 methods of taking images. Focus Stack This uses the partial area mode of the camera to take 232 frames of 10,240 pixels each, which I'm guessing to be 2048 \u00d7 5 pixels. There are probably 4 modes of trigger: Unknown ZYT 0 2 Start \\(z\\) -ramp when first camera image trigger pulse is sent (past camera clearing lines). ZYT 0 3 Start \\(z\\) -ramp and trigger camera immediately. ZYT {y} 4 Start \\(z\\) -ramp when \\(y\\) reaches {y} . Small TDI TDIYARM 2 This is probably used to generate thumbnails. Generate image of size 4096 \u00d7 2688 pixels. Large TDI TDIYARM 3 Production run. Image the entire flow cell, generate image of size 4096 \u00d7 160000 pixels.","title":"Programs"},{"location":"programs/#focus-stack","text":"This uses the partial area mode of the camera to take 232 frames of 10,240 pixels each, which I'm guessing to be 2048 \u00d7 5 pixels. There are probably 4 modes of trigger: Unknown ZYT 0 2 Start \\(z\\) -ramp when first camera image trigger pulse is sent (past camera clearing lines). ZYT 0 3 Start \\(z\\) -ramp and trigger camera immediately. ZYT {y} 4 Start \\(z\\) -ramp when \\(y\\) reaches {y} .","title":"Focus Stack"},{"location":"programs/#small-tdi","text":"TDIYARM 2 This is probably used to generate thumbnails. Generate image of size 4096 \u00d7 2688 pixels.","title":"Small TDI"},{"location":"programs/#large-tdi","text":"TDIYARM 3 Production run. Image the entire flow cell, generate image of size 4096 \u00d7 160000 pixels.","title":"Large TDI"},{"location":"reference/","text":"Reference Laser cmd Laser commands Returns: Type Description [type] [description] set_power ( self , power , tol = 3 , timeout = 30 ) Laser can take a while to warm up. Parameters: Name Type Description Default power Annotated[int, 'mW'] [description] required tol Annotated[int, 'mW'] [description]. Defaults to 3. 3 Source code in src/imaging/laser.py @run_in_executor def set_power ( self , power : Annotated [ int , \"mW\" ], tol : Annotated [ int , \"mW\" ] = 3 , timeout : Annotated [ int , \"s\" ] = 30 ): \"\"\"Laser can take a while to warm up. Args: power (int): [description] tol (int): [description]. Defaults to 3. \"\"\" assert all (( int ( power ) == power and power > 0 , timeout > 0 , tol > 0 )) if not self . on : self . on = True self . com . send ( is_between ( LaserCmd . SET_POWER , * self . POWER_RANGE )( power )) for _ in range ( timeout ): time . sleep ( 1 ) if abs ( power - self . power ) < tol : return True else : return False LaserCmd Laser commands Returns: Type Description [type] [description] Lasers dataclass Lasers(g: src.imaging.laser.Laser, r: src.imaging.laser.Laser)","title":"Reference"},{"location":"reference/#reference","text":"","title":"Reference"},{"location":"reference/#src.imaging.laser.Laser","text":"","title":"Laser"},{"location":"reference/#src.imaging.laser.Laser.cmd","text":"Laser commands Returns: Type Description [type] [description]","title":"cmd"},{"location":"reference/#src.imaging.laser.Laser.set_power","text":"Laser can take a while to warm up. Parameters: Name Type Description Default power Annotated[int, 'mW'] [description] required tol Annotated[int, 'mW'] [description]. Defaults to 3. 3 Source code in src/imaging/laser.py @run_in_executor def set_power ( self , power : Annotated [ int , \"mW\" ], tol : Annotated [ int , \"mW\" ] = 3 , timeout : Annotated [ int , \"s\" ] = 30 ): \"\"\"Laser can take a while to warm up. Args: power (int): [description] tol (int): [description]. Defaults to 3. \"\"\" assert all (( int ( power ) == power and power > 0 , timeout > 0 , tol > 0 )) if not self . on : self . on = True self . com . send ( is_between ( LaserCmd . SET_POWER , * self . POWER_RANGE )( power )) for _ in range ( timeout ): time . sleep ( 1 ) if abs ( power - self . power ) < tol : return True else : return False","title":"set_power()"},{"location":"reference/#src.imaging.laser.LaserCmd","text":"Laser commands Returns: Type Description [type] [description]","title":"LaserCmd"},{"location":"reference/#src.imaging.laser.Lasers","text":"Lasers(g: src.imaging.laser.Laser, r: src.imaging.laser.Laser)","title":"Lasers"}]}
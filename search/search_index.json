{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home This project repurposes the Illumina HiSeq 2000/2500 into an epifluorescence microscope with fluidics control. An overarching goal is to provide an accessible production-level software to control the HiSeq. The system could be controlled through a command line interface and a web interface. PySeq 2501 is written in Python 3.10 but should also work with 3.9. Acknowledgements This repurposing project is possible thanks to the pioneering work of Pandit et al. for PySeq2500 ( GitHub ). Much of the technical details and breadcrumbs are available thanks to the HiSeq2000 - Next Level Hacking project from Urs Gaudenz and the ReSeq Hackteria team.","title":"Home"},{"location":"#home","text":"This project repurposes the Illumina HiSeq 2000/2500 into an epifluorescence microscope with fluidics control. An overarching goal is to provide an accessible production-level software to control the HiSeq. The system could be controlled through a command line interface and a web interface. PySeq 2501 is written in Python 3.10 but should also work with 3.9.","title":"Home"},{"location":"#acknowledgements","text":"This repurposing project is possible thanks to the pioneering work of Pandit et al. for PySeq2500 ( GitHub ). Much of the technical details and breadcrumbs are available thanks to the HiSeq2000 - Next Level Hacking project from Urs Gaudenz and the ReSeq Hackteria team.","title":"Acknowledgements"},{"location":"architecture/","text":"Architecture Serial The HiSeq is controlled by multiple serial ports, with each port typically corresponding to an instrument. Some of the instruments are controlled by the FPGA or the \"computer\" of the HiSeq, which itself is also controlled by a serial port. All serial ports are connected to the computer through a single USB port. A single thread, running an asynchronous event loop, serves as a bridge for all serial communications. This allows concurrent signaling across multiple instruments, dramatically increasing the throughput of the system. Multiple commands could be sent at once and each incoming message could be processed nearly instantaneously without waiting for the last command to finish. Communication through the serial port is exceptionally slow (9600 bps or 9600 kHz for each character not including the response time). Therefore, all functions that involve the serial interface or requires any waiting are run in its own thread. That is, each function should never block the main thread to maintain responsiveness. Commands Commands are strings that are sent through the serial port to each instrument, similar to text messaging. Some commands evoke a return from an instrument. Lists of commands are available in the beginning of all instrument files and at {class}.cmd . Commands can be of two formats: Callable[..., str] or str for commands with and without arguments. To ensure that there are no silent failures, all responses to commands are compared against the expected response. Any unexpected response throws an Exception . The command and its parser are bundled together in the CmdParse object. Sending a CmdParse command results in a Future object, which could be used to access the parsed response once it is completed. Camera PySeq 2501 communicates with the camera through a DLL file dcamapi.dll from Hamamatsu, which probably communicates with the camera through Camera Link . PySeq 2501 is only guaranteed to work with the original driver version from Illumina. The driver is available upon ReAsOnAbLe ReQuEsT. I have tried the latest API from Hamamatsu without much success. The response time is also much better than that over serial communication. Each camera is individually connected to the frame grabber card.","title":"Architecture"},{"location":"architecture/#architecture","text":"","title":"Architecture"},{"location":"architecture/#serial","text":"The HiSeq is controlled by multiple serial ports, with each port typically corresponding to an instrument. Some of the instruments are controlled by the FPGA or the \"computer\" of the HiSeq, which itself is also controlled by a serial port. All serial ports are connected to the computer through a single USB port. A single thread, running an asynchronous event loop, serves as a bridge for all serial communications. This allows concurrent signaling across multiple instruments, dramatically increasing the throughput of the system. Multiple commands could be sent at once and each incoming message could be processed nearly instantaneously without waiting for the last command to finish. Communication through the serial port is exceptionally slow (9600 bps or 9600 kHz for each character not including the response time). Therefore, all functions that involve the serial interface or requires any waiting are run in its own thread. That is, each function should never block the main thread to maintain responsiveness.","title":"Serial"},{"location":"architecture/#commands","text":"Commands are strings that are sent through the serial port to each instrument, similar to text messaging. Some commands evoke a return from an instrument. Lists of commands are available in the beginning of all instrument files and at {class}.cmd . Commands can be of two formats: Callable[..., str] or str for commands with and without arguments. To ensure that there are no silent failures, all responses to commands are compared against the expected response. Any unexpected response throws an Exception . The command and its parser are bundled together in the CmdParse object. Sending a CmdParse command results in a Future object, which could be used to access the parsed response once it is completed.","title":"Commands"},{"location":"architecture/#camera","text":"PySeq 2501 communicates with the camera through a DLL file dcamapi.dll from Hamamatsu, which probably communicates with the camera through Camera Link . PySeq 2501 is only guaranteed to work with the original driver version from Illumina. The driver is available upon ReAsOnAbLe ReQuEsT. I have tried the latest API from Hamamatsu without much success. The response time is also much better than that over serial communication. Each camera is individually connected to the frame grabber card.","title":"Camera"},{"location":"hiseq/","text":"HiSeq The system we have is a HiSeq 2000 from 2012. Detailed specifications could be found here . Basically, it's an epifluorescence microscope with an integrated fluidics system. Each channel is a Hamamatsu C10000-509 CCD camera with a resolution of 2048 \u00d7 128 pixels. We would typically use the TDI (time delay and integration) mode. Briefly, we synchronize the speed of the stage and signal collection such that a running charge remains \"stationary\" with respect to an image point. This is much better than a typical full \"area\" shot as we could not take an image when we are moving. The design of the HiSeq could be understood in terms of its original purpose. The system needs to image diffraction-limited points on a 2D plane over distances in the order of centimeters. Using TDI, we could image an entire vertical slice of a flow cell at high-speed without stitching. Another issue is \\(z\\) -drift. This is dealt with by using 3 separate motors to control the stage height and tilt. The next problem would be ensuring that two parallel images start and end exactly at the same place. This is presumably done by using a direct FPGA-camera link that can send precise \"trigger\" signals. The FPGA can precisely trigger the camera when the \\(y\\) position and \\(z\\) position reaches a certain value.","title":"Overview"},{"location":"hiseq/#hiseq","text":"The system we have is a HiSeq 2000 from 2012. Detailed specifications could be found here . Basically, it's an epifluorescence microscope with an integrated fluidics system. Each channel is a Hamamatsu C10000-509 CCD camera with a resolution of 2048 \u00d7 128 pixels. We would typically use the TDI (time delay and integration) mode. Briefly, we synchronize the speed of the stage and signal collection such that a running charge remains \"stationary\" with respect to an image point. This is much better than a typical full \"area\" shot as we could not take an image when we are moving. The design of the HiSeq could be understood in terms of its original purpose. The system needs to image diffraction-limited points on a 2D plane over distances in the order of centimeters. Using TDI, we could image an entire vertical slice of a flow cell at high-speed without stitching. Another issue is \\(z\\) -drift. This is dealt with by using 3 separate motors to control the stage height and tilt. The next problem would be ensuring that two parallel images start and end exactly at the same place. This is presumably done by using a direct FPGA-camera link that can send precise \"trigger\" signals. The FPGA can precisely trigger the camera when the \\(y\\) position and \\(z\\) position reaches a certain value.","title":"HiSeq"},{"location":"programs/","text":"From the logs, there are 3 methods of taking images. Focus Stack This uses the partial area mode of the camera to take 232 frames of 10,240 pixels each, which I'm guessing to be 2048 \u00d7 5 pixels. There are probably 4 modes of trigger: Unknown ZYT 0 2 Start \\(z\\) -ramp when first camera image trigger pulse is sent (past camera clearing lines). ZYT 0 3 Start \\(z\\) -ramp and trigger camera immediately. ZYT {y} 4 Start \\(z\\) -ramp when \\(y\\) reaches {y} . Small TDI TDIYARM 2 This is probably used to generate thumbnails. Generate image of size 4096 \u00d7 2688 pixels. Large TDI TDIYARM 3 Production run. Image the entire flow cell, generate image of size 4096 \u00d7 160000 pixels.","title":"Programs"},{"location":"programs/#focus-stack","text":"This uses the partial area mode of the camera to take 232 frames of 10,240 pixels each, which I'm guessing to be 2048 \u00d7 5 pixels. There are probably 4 modes of trigger: Unknown ZYT 0 2 Start \\(z\\) -ramp when first camera image trigger pulse is sent (past camera clearing lines). ZYT 0 3 Start \\(z\\) -ramp and trigger camera immediately. ZYT {y} 4 Start \\(z\\) -ramp when \\(y\\) reaches {y} .","title":"Focus Stack"},{"location":"programs/#small-tdi","text":"TDIYARM 2 This is probably used to generate thumbnails. Generate image of size 4096 \u00d7 2688 pixels.","title":"Small TDI"},{"location":"programs/#large-tdi","text":"TDIYARM 3 Production run. Image the entire flow cell, generate image of size 4096 \u00d7 160000 pixels.","title":"Large TDI"},{"location":"reference/","text":"Reference Laser ( UsesSerial ) Source code in pyseq2/imaging/laser.py class Laser ( UsesSerial ): cmd = LaserCmd @classmethod async def ainit ( cls , name : Literal [ \"r\" , \"g\" ], port_tx : str ) -> Laser : self = cls () self . com = await COM . ainit ( cast ( SerialInstruments , \"laser_\" + name ), port_tx = port_tx ) await self . initialize () return self def __init__ ( self ) -> None : # The second command will be eaten if sent before the first one returns. self . lock = asyncio . Lock () self . com : COM async def initialize ( self ) -> None : await self . com . send ( LaserCmd . VERSION ) async def set_onoff ( self , state : bool , attempts : int = 3 ) -> None : async with self . lock : await self . com . send ({ False : LaserCmd . OFF , True : LaserCmd . ON }[ state ]) # while (resp := self.status.result(5)) is None: # ... # if resp == state: # break # else: # raise LaserException( # f\"Laser did not switch to {state} after {attempts} attempts. Check if all doors are 'closed'.\" # ) # return resp async def set_power ( self , power : Annotated [ int , \"mW\" ], tol : Annotated [ int , \"mW\" ] = 3 ) -> None : \"\"\"Laser can take a while to warm up. Args: power (int): [description] tol (int): [description]. Defaults to 3. \"\"\" async with self . lock : assert all (( int ( power ) == power and power > 0 , tol > 0 )) if not self . on : await self . set_onoff ( True ) await self . com . send ( LaserCmd . SET_POWER ( int ( power ))) # for _ in range(timeout): # time.sleep(1) # if abs(power - not_none(self.power.result(5))) < tol: # return True # else: # return False @property async def status ( self ) -> bool : async with self . lock : return await self . com . send ( LaserCmd . GET_STATUS ) async def on ( self ) -> None : return await self . set_onoff ( True ) async def off ( self ) -> None : return await self . set_onoff ( False ) @property async def power ( self ) -> int : async with self . lock : return await self . com . send ( LaserCmd . GET_POWER ) set_power ( self , power , tol = 3 ) async Laser can take a while to warm up. Parameters: Name Type Description Default power int [description] required tol int [description]. Defaults to 3. 3 Source code in pyseq2/imaging/laser.py async def set_power ( self , power : Annotated [ int , \"mW\" ], tol : Annotated [ int , \"mW\" ] = 3 ) -> None : \"\"\"Laser can take a while to warm up. Args: power (int): [description] tol (int): [description]. Defaults to 3. \"\"\" async with self . lock : assert all (( int ( power ) == power and power > 0 , tol > 0 )) if not self . on : await self . set_onoff ( True ) await self . com . send ( LaserCmd . SET_POWER ( int ( power ))) # for _ in range(timeout): # time.sleep(1) # if abs(power - not_none(self.power.result(5))) < tol: # return True # else: # return False Lasers dataclass Lasers(g: 'Laser', r: 'Laser') Source code in pyseq2/imaging/laser.py @dataclass class Lasers : g : Laser r : Laser @property async def power ( self ) -> tuple [ int , int ]: return await asyncio . gather ( self . g . power , self . r . power ) def __iter__ ( self ) -> Iterator [ Laser ]: yield self . g yield self . r def __getitem__ ( self , id_ : Literal [ 0 , 1 ]) -> Laser : match id _ : case 0 : return self . g case 1 : return self . r case _ : raise ValueError ( \"Invalid laser id.\" ) # def initialize(self) -> list[Future[Any]]: # return [getattr(self, f.name).initialize() for f in fields(self)] # def on(self): # return (self.g.on(), self.r.on()) # def off(self): # return (self.g.off(), self.r.off())","title":"Reference"},{"location":"reference/#reference","text":"","title":"Reference"},{"location":"reference/#pyseq2.imaging.laser.Laser","text":"Source code in pyseq2/imaging/laser.py class Laser ( UsesSerial ): cmd = LaserCmd @classmethod async def ainit ( cls , name : Literal [ \"r\" , \"g\" ], port_tx : str ) -> Laser : self = cls () self . com = await COM . ainit ( cast ( SerialInstruments , \"laser_\" + name ), port_tx = port_tx ) await self . initialize () return self def __init__ ( self ) -> None : # The second command will be eaten if sent before the first one returns. self . lock = asyncio . Lock () self . com : COM async def initialize ( self ) -> None : await self . com . send ( LaserCmd . VERSION ) async def set_onoff ( self , state : bool , attempts : int = 3 ) -> None : async with self . lock : await self . com . send ({ False : LaserCmd . OFF , True : LaserCmd . ON }[ state ]) # while (resp := self.status.result(5)) is None: # ... # if resp == state: # break # else: # raise LaserException( # f\"Laser did not switch to {state} after {attempts} attempts. Check if all doors are 'closed'.\" # ) # return resp async def set_power ( self , power : Annotated [ int , \"mW\" ], tol : Annotated [ int , \"mW\" ] = 3 ) -> None : \"\"\"Laser can take a while to warm up. Args: power (int): [description] tol (int): [description]. Defaults to 3. \"\"\" async with self . lock : assert all (( int ( power ) == power and power > 0 , tol > 0 )) if not self . on : await self . set_onoff ( True ) await self . com . send ( LaserCmd . SET_POWER ( int ( power ))) # for _ in range(timeout): # time.sleep(1) # if abs(power - not_none(self.power.result(5))) < tol: # return True # else: # return False @property async def status ( self ) -> bool : async with self . lock : return await self . com . send ( LaserCmd . GET_STATUS ) async def on ( self ) -> None : return await self . set_onoff ( True ) async def off ( self ) -> None : return await self . set_onoff ( False ) @property async def power ( self ) -> int : async with self . lock : return await self . com . send ( LaserCmd . GET_POWER )","title":"Laser"},{"location":"reference/#pyseq2.imaging.laser.Laser.set_power","text":"Laser can take a while to warm up. Parameters: Name Type Description Default power int [description] required tol int [description]. Defaults to 3. 3 Source code in pyseq2/imaging/laser.py async def set_power ( self , power : Annotated [ int , \"mW\" ], tol : Annotated [ int , \"mW\" ] = 3 ) -> None : \"\"\"Laser can take a while to warm up. Args: power (int): [description] tol (int): [description]. Defaults to 3. \"\"\" async with self . lock : assert all (( int ( power ) == power and power > 0 , tol > 0 )) if not self . on : await self . set_onoff ( True ) await self . com . send ( LaserCmd . SET_POWER ( int ( power ))) # for _ in range(timeout): # time.sleep(1) # if abs(power - not_none(self.power.result(5))) < tol: # return True # else: # return False","title":"set_power()"},{"location":"reference/#pyseq2.imaging.laser.Lasers","text":"Lasers(g: 'Laser', r: 'Laser') Source code in pyseq2/imaging/laser.py @dataclass class Lasers : g : Laser r : Laser @property async def power ( self ) -> tuple [ int , int ]: return await asyncio . gather ( self . g . power , self . r . power ) def __iter__ ( self ) -> Iterator [ Laser ]: yield self . g yield self . r def __getitem__ ( self , id_ : Literal [ 0 , 1 ]) -> Laser : match id _ : case 0 : return self . g case 1 : return self . r case _ : raise ValueError ( \"Invalid laser id.\" ) # def initialize(self) -> list[Future[Any]]: # return [getattr(self, f.name).initialize() for f in fields(self)] # def on(self): # return (self.g.on(), self.r.on()) # def off(self): # return (self.g.off(), self.r.off())","title":"Lasers"}]}